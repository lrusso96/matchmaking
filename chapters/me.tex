\chapter{Matchmaking Encryption}

\section{The General Setting}
Formally, an ME is composed of the following polynomial-time algorithms:
\begin{description}\label{def:dnish}
    \item[$\setup(\secparam)$:] Upon input the security parameter $\secparam$ the randomized setup algorithm outputs the master public key $\mpk$, the master policy key $\kpol$, and the master secret key $\msk$.
          We implicitly assume that all other algorithms take $\mpk$ as input.
    \item[$\skgen(\msk, \sattr)$:] The randomized sender-key generator takes as input the master secret key $\msk$, and attributes $\sattr\in\bin^*$. The algorithm outputs a secret encryption key $\ek_{\sattr}$ for attributes $\sattr$.
    \item[$\rkgen(\msk, \rattr)$:] The randomized receiver-key generator takes as input the master secret key $\msk$, and attributes $\rattr\in\bin^*$. The algorithm outputs a secret decryption key $\dk_{\rattr}$ for attributes $\rattr$.
    \item[$\polgen(\kpol, \saccess)$:] The randomized receiver policy generator takes as input the master policy key $\kpol$, and a policy $\saccess:\allowbreak\bin^*\rightarrow\bin$ represented as a circuit. The algorithm outputs a secret decryption key $\dk_{\saccess}$ for the circuit $\saccess$.
    \item[$\enc(\ek_{\sattr}, \raccess, \msg)$:] The randomized encryption algorithm takes as input a secret encryption key $\ek_{\sattr}$ for attributes $\sattr \in \bin^*$, a policy $\raccess:\bin^*\rightarrow\bin$ represented as a circuit, and a message $\msg\in\cMSG$. The algorithm produces a ciphertext $\cipher$ linked to both $\sattr$ and $\raccess$.
    \item[$\dec(\dk_{\rattr}, \dk_{\saccess}, \cipher)$:] The deterministic decryption algorithm takes as input a secret decryption key $\dk_{\rattr}$ for attributes $\rattr \in \bin^*$, a secret decryption key $\dk_{\saccess}$ for a circuit $\saccess:\bin^*\rightarrow\bin$, and a ciphertext $\cipher$.
          The algorithm outputs either a message $\msg$ or  $\bot$ (denoting an error).
\end{description}

\paragraph*{Correctness.} Correctness intuitively says that decrypting an honestly generated ciphertext which encrypts a message $\msg$ using sender's attributes $\sattr$ and policy $\raccess$ using decryption keys for receiver's attributes $\rattr$ and access policy $\saccess$ should equal $\msg$ if and only if the receiver's attributes $\rattr$ match the policy $\raccess$ specified by the sender, and at the same time the sender's attributes $\sattr$ match the policy $\saccess$ specified by the receiver. On the other hand, in case of mismatch, the decryption algorithm returns $\bot$.
More formally:
\begin{definition}[Correctness of ME]\label{def:DNISHcorrectness}
    An ME with message space $\cMSG$ is correct if $\forall\secpar\in\NN$, $\forall (\mpk, \kpol, \msk)$ output by $\setup(\secparam)$,
    $\forall \msg \in \cMSG$, $\forall \sattr,\rattr \in \bin^*$,
    $\forall \raccess,\saccess:\bin^*\rightarrow\bin$:
    \[
        \Prob{\dec(\dk_{\rattr}, \dk_{\saccess}, \enc(\ek_{\sattr}, \raccess, \msg)) = \msg} \geq 1 - \negl,
    \]
    whenever $\saccess(\sattr)=1$ and $\raccess(\rattr)=1$, and otherwise
    \[
        \Prob{\dec(\dk_{\rattr}, \dk_{\saccess}, \enc(\ek_{\sattr}, \raccess, \msg)) = \bot} \geq 1 - \negl,
    \]
    where $\ek_{\sattr} \getsr \skgen(\msk, \sattr)$, $\dk_{\rattr} \getsr \rkgen(\allowbreak\msk, \rattr)$, $\dk_{\saccess} \getsr \polgen(\kpol, \saccess)$.
\end{definition}

\section{The Arranged Setting}
\todo[inline]{Add formal definitions}
