\begin{construction}\label{constr:me_nizk_priv}
    Let $\Pi'=(\setup',\skgen',\rkgen', \polgen', \enc',\dec')$ be an ME scheme, and $\nizk=(\init,\prover,\verifier)$ be a $f$-tSE NIZK argument for the following NP relation:

    \[
        R \eqdef \Biggl\{ \begin{array}{c}((\sattr, \raccess, \msg, r),(\mpk',\cipher))\end{array}:\begin{array}{@{}c}
            \cipher = \enc'(\ek'_\sattr, \raccess, \msg; r)
        \end{array} \Biggr\}.
    \]
    \newline\newline
    We construct the new ME scheme $\Pi$ as follows:
    \begin{description}
        \item[$\setup(\secparam)$:] on input the security parameter, gets $(\msk', \kpol, \mpk') \getsr \setup'(\secparam)$, and $\crs \getsr \init(\secparam)$. Then outputs $\msk = (\msk', \kpol)$ as the master secret key and $\mpk = (\mpk', \crs)$ as the master public key. All other algorithms are implicitly given $\mpk$ as additional input.
        \item[$\skgen(\msk, \sattr)$:] the randomized sender-key generator takes as input the master secret key $\msk$ and attributes $\sattr \in \bin^*$. The algorithm returns the encryption key $\ek_\sattr \getsr \skgen'(\msk', \sattr)$.
        \item[$\rkgen(\msk, \rattr)$:] the randomized receiver-key generator takes as input the master secret key $\msk$ and attributes $\rattr \in \bin^*$. The algorithm computes the key $\dk_\rattr \getsr \rkgen'(\msk', \rattr)$.
        \item[$\polgen(\kpol, \saccess)$:] the receiver policy generator takes as input the master policy key $\kpol$ and a policy $\saccess: \bin^* \to \bin$ and outputs $\dk_\saccess \getsr \polgen'(\kpol, \saccess)$.
        \item[$\enc(\ek_\sattr, \raccess, \msg)$:] the randomized encryption algorithm takes as input a secret encryption key $ek_\sattr$ for attributes $\sattr \in \bin^*$, a policy $\raccess: \bin^* \to \bin$ and a message $\msg \in \bin^*$. The algorithm first encrypts the message by computing $\cipher' \getsr \enc'(\ek_\sattr, \raccess, \msg)$; then, it returns the ciphertext $\cipher = (\cipher', \pi)$, where $\pi \getsr \prover(\crs, (\sattr, \raccess, \msg, r),(\mpk', \cipher))$.
        \item[$\dec(\dk_\rattr, \dk_\saccess, \cipher)$:] the deterministic decryption algorithm takes as input a secret decryption key $\dk_\rattr = \dk'_\rattr$, a secret decryption key $\dk_\saccess = \dk'_\saccess$ for a circuit $\saccess: \bin^* \to \bin$ and a ciphertext $\cipher = (\cipher', \pi)$. The algorithm first checks whether $\verifier(\crs, (\cipher', \mpk'), \pi) = 0$: if true, it simply returns $\bot$; otherwise, it returns $\dec'(\dk'_\rattr, \dk_\saccess, \cipher')$.
    \end{description}
\end{construction}