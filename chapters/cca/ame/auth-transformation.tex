\begin{theorem}\label{theo:ame_nizk_auth}
    Let $\Pi', \sig, \nizk$ be as above.
    If $\Pi'$ has CPA authenticity, $\sig$ is EUF-CMA secure and $\nizk$ satisfies true-simulation extractability for $f(\sattr, \signature, \raccess, \msg, r) = (\sattr, \raccess, \msg)$, then the ME scheme $\Pi$ from construction~\ref{constr:ame_nizk} achieves CCA authenticity and preserves its privacy.
\end{theorem}

\begin{proof}
    We can separately prove the two properties, by using Lemma~\ref{lemma:ame_priv_same} and Lemma~\ref{lemma:ame_auth}

    \begin{lemma}\label{lemma:ame_priv_same}
        Construction~\ref{constr:ame_nizk} preserves CPA (resp. CCA) privacy.
        \begin{proof}
            Let assume that $\Pi$ does not preserve its privacy. This implies that there exists a valid $\adversary$ able to win with non negligible probability $\NISHmatchgame{\arranged}_{\Pi, \adversary}(\secpar)$ (resp. $\NISHmatchgamecca{\arranged}_{\Pi, \adversary}(\secpar)$). If this is the case, we can build a valid $\adversary'$ to win with non negligible probability $\NISHmatchgame{\arranged}_{\Pi', \adversary}(\secpar)$ (resp. $\NISHmatchgamecca{\arranged}_{\Pi', \adversary}(\secpar)$). The reduction is the following.

            \begin{enumerate}
                \item (setup) $\adversary'$ receives the master public key $\mpk'$ from the challenger. Then it computes $(\crs,\tpsim,\tpext)\getsr\nizkext_0(\secparam)$, the signatures keys $(\sk, \pk) \getsr \kgen(\secparam)$ and gives $\adversary$ the new master public key $\mpk = (\mpk', \pk, \crs)$.
                \item ($\ora_1$) on input $\sattr$, $\adversary'$ invokes $\ora_1(\sattr)$ to have back $\ek'_\sattr$; moreover, it computes $\signature \getsr \sign(\sk, \sattr)$. Then it gives $\adversary$ the new sender key $\ek_\sattr = (\ek'_\sattr, \signature)$.
                \item ($\ora_2$) on input $\rattr$, $\adversary'$ invokes $\ora_2(\rattr)$ and forwards the received $\ek'_\rattr$.
                \item (decryption - $\ora_3$)\footnote{Only for CCA game.} on input $(\rattr, \saccess, (\cipher', \pi))$, it first parses the ciphertext and checks whether the proof $\pi$ is valid or not (in this case simply outputs $\bot$). Then, invokes $\ora_3$ and forwards the result.
                \item (challenge) the input tuple is passed to the challenger that computes $\cipher'_b$; $\adversary'$ returns back $(\cipher'_b, \pi)$, where $\pi = \nizksim_1(\tpsim, \cipher'_b)$ is a simulated proof for $\cipher'_b$.
                \item (output) the bit $b'$ is given to the challenger.
            \end{enumerate}
            ~\newline
            The view offered by $\adversary'$ to $\adversary$ is computationally close to the original one: the difference is due to the different mechanism to generate the CRS $\crs$, but this cannot be distinguished by $\adversary$, because of the assumption of f-tSE of $\nizk$.
            Oracles $\ora_2$, $\ora_3$ are perfectly simulated, since they are offered directly by the challenger.
            $\ora_1$ queries are again perfectly simulated, because the sender key is honestly generated by the challenger and the signature is valid (and verifiable by $\adversary$).
        \end{proof}
    \end{lemma}

    \begin{lemma}\label{lemma:ame_auth}
        Construction~\ref{constr:ame_nizk} achieves CCA-authenticity.
        \begin{proof}
            The proof is almost the same as Lemma ~\ref{lemma:me_auth}: the only difference is that here we do not need to simulate anymore the generation of the policy keys.
            Let assume $\Pi$ does not achieve CCA-authenticity. This implies that there exists a valid $\adversary$ able to win with non negligible probability $\NISHeufgamecca{\arranged}_{\Pi, \adversary}(\secpar)$. If this is the case, we can build a valid $\adversary'$ to win with non negligible probability $\Sigeufgame_{\sig, \adversary'}(\secpar)$. The reduction is the following.

            \begin{enumerate}
                \item (setup) $\adversary'$ receives the public key $\pk$ from the challenger. Then it generates the keys $(\msk', \kpol, \mpk') \getsr \setup'(\secparam)$ together with $(\crs,\tpsim,\tpext)\getsr\nizkext_0(\secparam)$. It gives $\adversary$ the master public key $\mpk = (\mpk', \pk, \crs)$.
                \item ($\ora_1$) on input $\sattr$, $\adversary'$ invokes $\ora_\sign(\sattr)$ to receive a valid signature $\signature$ for $\sattr$. Then it runs $\ek'_\sattr \getsr \skgen'(\msk, \sattr)$ and returns $\ek_\sattr = (\ek_\sattr', \signature)$.
                \item ($\ora_2$) on input $(\rattr, \saccess)$, $\adversary'$ returns $\ek'_{\rattr, \saccess} \getsr \rkgen'(\msk, \rattr, \saccess)$.
                \item (encryption - $\ora_4$) on input the tuple $(\sattr, \raccess, \msg)$, it computes a valid ciphertext $\cipher' \getsr \enc'(\ek'_\sattr, \raccess, \msg)$, for some $\ek'_\sattr \getsr \skgen'(\msk, \sattr)$. Then returns $\cipher = (\cipher', \pi)$, for a simulated proof $\pi = \nizksim_1(\tpsim, \cipher')$.
                \item (challenge) on input $((\cipher', \pi), \rattr, \saccess)$, extracts $(\sattr, \signature)$, running $\nizkext_1(\tpext, \cipher', \pi)$, and forwards the tuple to the challenger.
            \end{enumerate}
            ~\newline
            First of all, note that on setup $\adversary'$ simulates an honest challenger for $\adversary$ in all but a single event: the setup of the CRS $\crs$, indeed, is done through $\nizkext_0$, which allows $\adversary'$ to obtain the useful trapdoors. But this, clearly, does not alter (except with some negligible probability) the view of $\adversary$, because of the assumption of true-simulation extractability of $\nizk$: moreover, for the very same reason, the distribution of the proofs generated by $\ora_4$ is computationally close to the original one.
            The simulation of $\ora_2$ is tight, since it only requires keys honestly generated by $\adversary'$.
            Also $\ora_1$ queries are perfectly simulated, because of the powerful $\ora_\sign$ offered by the challenger, which allows $\adversary'$ to compute a valid signature on the sender attributes, thus preserving the correctness.
            ~\newline\newline
            So, by assumption, $\adversary$ wins the game with some non negligible probability, thus producing a tuple $((\cipher', \pi), \rattr, \saccess)$; in order to be acceptable, such tuple should be such that the proof is accepted and, except with some negligible probability, the extractor $\nizkext_1$ is able to reconstruct the sender attributes $\sattr$ and a valid $\signature$ on the very same attributes.
            Note that, since $\adversary$ is valid, $\adversary'$ never queries $\ora_\sign(\sattr)$: so $(\sattr, \signature)$ is a valid forgery for $\Sigeufgame_{\sig, \adversary'}(\secpar)$.
        \end{proof}
    \end{lemma}
    Since we have shown that Construction~\ref{constr:ame_nizk} achieves CCA-authenticity and preserves its privacy, we have concluded the proof.
\end{proof}
